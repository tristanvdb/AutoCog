// /workspace/libs/autocog/parser/stl/lexer.hxx generated by reflex 6.0.0 from /workspace/libs/autocog/parser/stl/lexer.l

#ifndef REFLEX__WORKSPACE_LIBS_AUTOCOG_PARSER_STL_LEXER_HXX
#define REFLEX__WORKSPACE_LIBS_AUTOCOG_PARSER_STL_LEXER_HXX
#define IN_HEADER 1
#define REFLEX_VERSION "6.0.0"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#undef REFLEX_OPTION_header_file
#undef REFLEX_OPTION_lex
#undef REFLEX_OPTION_lexer
#undef REFLEX_OPTION_namespace
#undef REFLEX_OPTION_noyywrap
#undef REFLEX_OPTION_outfile

#define REFLEX_OPTION_header_file         "/workspace/libs/autocog/parser/stl/lexer.hxx"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_namespace           autocog::parser
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "/workspace/libs/autocog/parser/stl/lexer.cxx"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "/workspace/libs/autocog/parser/stl/lexer.l"

#include "autocog/parser/stl/token.hxx"
#include "autocog/parser/stl/location.hxx"
#include <string>


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace autocog {
namespace parser {

class Lexer : public reflex::AbstractLexer<reflex::Matcher> {
#line 7 "/workspace/libs/autocog/parser/stl/lexer.l"

private:
    int line_number = 1;
    int column_number = 1;
    int last_column = 1;
    unsigned current_offset = 0;

    void update_location() {
        last_column = column_number;
        column_number += size();
        current_offset += size();
    }

    void newline() {
        line_number++;
        last_column = column_number;
        column_number = 1;
        current_offset++;
    }

public:
    SourceLocation current_location() const {
        return {line_number, last_column, current_offset};
    }

    Token advance() {
        TokenType tok = (TokenType)(this->lex());
        Token token{ tok, this->str(), this->current_location() };
        return token;
    }

 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Lexer(
      // a persistent source of input, empty by default
      const reflex::Input& input = reflex::Input(),
      // optional output stream, std::cout by default
      std::ostream& os = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  // the lexer function defined by SECTION 2
  virtual int lex(void);
  // lexer functions accepting new input to scan
  int lex(const reflex::Input& input)
  {
    in(input);
    return lex();
  }
  int lex(const reflex::Input& input, std::ostream *os)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

} // namespace autocog
} // namespace parser

#endif
