
#include "convert.hxx"

#include "autocog/llama/xfta/model.hxx"
#include "autocog/llama/xfta/evaluation.hxx"
#include "autocog/llama/xfta/manager.hxx"

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/numpy.h>

#include <optional>

#if VERBOSE
#  include <iostream>
#endif
#define DEBUG_pybind_evaluate VERBOSE && 0

PYBIND11_MODULE(xfta_cxx, module) {
  using namespace autocog::llama::xfta;

  Manager::initialize();

  module.doc() = "AutoCog's llama.cpp integration module";

  module.def("create",
    [](std::string const & model_path, int n_ctx) {
      return Manager::add_model(model_path, n_ctx);
    },
    "Instantiate a GGML model with llama.cpp",
    pybind11::arg("model_path"),
    pybind11::arg("n_ctx") = 4096
  );
    
  module.def("vocab_size", [](ModelID model) {
    return Manager::get_model(model).vocab_size();
  }, "Get vocabulary size");

  module.def("tokenize",
    [](ModelID model, const std::string & text, bool add_bos, bool special) {
      auto tokens = Manager::get_model(model).tokenize(text, add_bos, special);
      pybind11::list result;
      for (auto token : tokens) result.append(token);
      return result;
    },
    "Tokenize text using llama.cpp",
    pybind11::arg("model"),
    pybind11::arg("text"), 
    pybind11::arg("add_bos") = false,
    pybind11::arg("special") = false
  );
    
  module.def("detokenize",
    [](ModelID model, const pybind11::list & py_tokens, bool spec_rm, bool spec_unp) {
      TokenSequence tokens;
      for (auto item : py_tokens) tokens.push_back(item.cast<TokenID>());
      return Manager::get_model(model).detokenize(tokens, spec_rm, spec_unp);
    },
    "Detokenize tokens to text",
    pybind11::arg("model"),
    pybind11::arg("tokens"),
    pybind11::arg("spec_rm") = false,
    pybind11::arg("spec_unp") = false
  );
    
  module.def("evaluate",
    [](ModelID model, pybind11::dict const & fta_dict) {
#if DEBUG_pybind_evaluate
      std::cerr << "IN evaluate (pybind): START" << std::endl;
#endif
      FTA fta = convert_pydict_to_fta(model, fta_dict);
#if DEBUG_pybind_evaluate
      std::cerr << "IN evaluate (pybind): FTA" << std::endl;
#endif
      EvalID eval = Manager::add_eval(model, fta);
#if DEBUG_pybind_evaluate
      std::cerr << "IN evaluate (pybind): EVAL" << std::endl;
#endif
      Manager::advance(eval, std::nullopt);
#if DEBUG_pybind_evaluate
      std::cerr << "IN evaluate (pybind): FTT" << std::endl;
#endif
      FTT const & ftt = Manager::retrieve(eval);
#if DEBUG_pybind_evaluate
      std::cerr << "IN evaluate (pybind): RES" << std::endl;
#endif
      pybind11::dict res = convert_ftt_to_pydict(model, ftt);
#if DEBUG_pybind_evaluate
      std::cerr << "IN evaluate (pybind): CLEAN" << std::endl;
#endif
      Manager::rm_eval(eval);
#if DEBUG_pybind_evaluate
      std::cerr << "IN evaluate (pybind): DONE" << std::endl;
#endif
      return res;
    },
    "Evaluate a FTA using a model and return the FTT."
  );

#ifdef ASYNC_EXEC
  module.def("instantiate",
    [](ModelID model, pybind11::dict const & fta) {
      FTA fta_ = convert_pydict_to_fta(model, fta);
      // TODO
    },
    "Instantiate a FTA using a model and return the EvalID.",
    pybind11::arg("model"),
    pybind11::arg("fta")
  );

  module.def("advance", 
    [](EvalID eval, std::optional<unsigned> max_token_eval) {
      // TODO
    },
    "Advance a FTA evaluation with an optional (soft) limit on the number of token evaluation, return the number of evaluated tokens.",
    pybind11::arg("eval"),
    pybind11::arg("max_token_eval") = std::nullopt
  );

  module.def("advance_bg", 
    [](EvalID eval, std::optional<unsigned> max_token_eval) {
      // TODO
    },
    "Signal an evaluation to run in the background, return nothing immediately.",
    pybind11::arg("eval"),
    pybind11::arg("max_token_eval") = std::nullopt
  );

  module.def("finished", 
    [](EvalID eval) {
      // TODO
    },
    "Check if a FTA evaluation is finished.",
    pybind11::arg("eval")
  );

  module.def("retrieve", 
    [](EvalID eval) {
      // TODO
    },
    "Retrieve the FTT being generated by an evaluation.",
    pybind11::arg("eval")
  );

  module.def("release", 
    [](EvalID eval) {
      // TODO
    },
    "Wait for the evaluation to finish, retrieve the generated FTT, then remove the evaluation.",
    pybind11::arg("eval")
  );
#endif /* ASYNC_EXEC */
}

